package main

//In a network of nodes, each node i is directly connected to another node j if
//and only if graph[i][j] = 1.
//
// Some nodes initial are initially infected by malware. Whenever two nodes are
//directly connected and at least one of those two nodes is infected by malware, b
//oth nodes will be infected by malware. This spread of malware will continue unti
//l no more nodes can be infected in this manner.
//
// Suppose M(initial) is the final number of nodes infected with malware in the
//entire network, after the spread of malware stops.
//
// We will remove one node from the initial list. Return the node that if remove
//d, would minimize M(initial). If multiple nodes could be removed to minimize M(i
//nitial), return such a node with the smallest index.
//
// Note that if a node was removed from the initial list of infected nodes, it m
//ay still be infected later as a result of the malware spread.
//
//
//
//
//
//
// Example 1:
//
//
//Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
//Output: 0
//
//
// Example 2:
//
//
//Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
//Output: 0
//
//
// Example 3:
//
//
//Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
//Output: 1
//
//
//
//
// Note:
//
//
// 1 < graph.length = graph[0].length <= 300
// 0 <= graph[i][j] == graph[j][i] <= 1
// graph[i][i] == 1
// 1 <= initial.length <= graph.length
// 0 <= initial[i] < graph.length
//
// Related Topics Depth-first Search Union Find
// 👍 333 👎 268

// 2020-10-27 13:22:48

//leetcode submit region begin(Prohibit modification and deletion)
func minMalwareSpread(graph [][]int, initial []int) int {
	N := len(graph)
	// review, how to create an array with length
	colors := make([]int, N)

	for i := 0; i < len(graph); i++ {
		colors[i] = -1
	}

	var dfs func(int, int)

	dfs = func(node, color int) {
		colors[node] = color
		for nei := 0; nei < len(graph); nei++ {
			if graph[node][nei] == 1 && colors[nei] == -1 {
				dfs(nei, color)
			}
		}
	}

	c := 0
	for node := 0; node < len(graph); node++ {
		if colors[node] == -1 {
			dfs(node, c)
			c++
		}
	}

	size := make([]int, c)
	for _, color := range colors {
		size[color]++
	}

	colorCnt := make([]int, c)
	for _, node := range initial {
		colorCnt[colors[node]]++
	}

	ans := N + 1

	for _, node := range initial {
		color := colors[node]
		if colorCnt[color] == 1 {
			if ans == N+1 {
				ans = node
			} else if size[color] > size[colors[ans]] {
				ans = node
			} else if size[color] == size[colors[ans]] && node < ans {
				ans = node
			}
		}
	}

	min := func(x, y int) int {
		if x < y {
			return x
		}
		return y
	}

	if ans == N+1 {
		for _, node := range initial {
			ans = min(ans, node)
		}
	}

	return ans

}

//leetcode submit region end(Prohibit modification and deletion)
